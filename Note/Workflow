A. Main()函数逻辑
	a. 注册处理信号
	b. 初始化锁，条件锁
	c. 启动信号处理线程
	d. 注册程序退出处理函数
	e. 创建全局线程配置 【初始化|环境变量|命令行】
	f. 从全局配置中判断程序启动模式【守护进程|远程服务|客户端】【多线程|单线程】
	
B. 信号处理 【多线程|单线程】
	a. 常见要处理的信号:  
		1. SIGTERM: 软件退出，可被阻塞。
		2. SIGINT: 软件退出，Ctr+C 
		3. SIGALRM: 时钟定时信号
		4. SIGPIPE: 向一个没有读进程的管道写数据
		
	b. iperf信号处理：
		1. 只让第一个线程处理信号，其他线程仅仅设置信号标志
			....
			if ( thread_equalid( sThread, thread_zeroid() ) ) {
				sThread = thread_getid();	// 【第一次初始化】
			} else if ( thread_equalid( sThread, thread_getid() ) ) {	// 【判断是否为信号处理线程】
				sig_exit( inSigno );
			}
			// global variable used by threads to see if they were interrupted
			sInterupted = inSigno;
			....
		
C. 全局配置的初始化 【Setting.cpp|Setting.hpp】：
	a. 线程配置的结构体 - 客户端数据包格式 - 服务端数据包格式
	b. 线程配置的结构体
		兼容C和C++使用了结构体存储配置信息，使用位运算替代bool
		typedef struct thread_Settings {
			....
			int flags;
			....
		}
		....
		#define FLAG_BUFLENSET      0x00000001
		....
		#define isBuflenSet(settings)      ((settings->flags & FLAG_BUFLENSET) != 0)
		....
		#define setBuflenSet(settings)     settings->flags |= FLAG_BUFLENSET
		....
		
	c. 读取环境变量设置配置
		1. 使用GNU开源代码: gun_getopt.h
		2. 获取环境变量相关函数: char* getenv(const char* name);
		3. 如何程序参数与环境变量对应起来处理:
			....
			struct option {
				const char *name;	// 环境变量名
				int has_arg;
				int *flag;	// 【 getopt_long()函数解析struct option结构体; if (flag==NULL) { return val;} else { *flag=val; return 0}】
				int val;	// 程序参数
			};
			....
			char* theVariable = getenv(env_options[i].name);
			....
			Settings_Interpret( env_options[i].val, theVariable, mSettings );
			....
		4. 根据setting判断是否启动切换为守护进程
		
	d. 启动处理线程
		1. thread->runNow	【recusive】
		2. thread->runNext	【recusive】
	
		
		
		
		
		
		